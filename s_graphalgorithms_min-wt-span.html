<!DOCTYPE html>
<!--**************************************-->
<!--*    Generated from PreTeXt source   *-->
<!--*    on 2018-02-21T12:07:43Z    *-->
<!--*                                    *-->
<!--*   http://mathbook.pugetsound.edu   *-->
<!--*                                    *-->
<!--**************************************-->
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Minimum Weight Spanning Trees</title>
<meta name="Keywords" content="Authored in PreTeXt">
<meta name="viewport" content="width=device-width,  initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
<script type="text/javascript" src="https://sagecell.sagemath.org/static/jquery.min.js"></script><script type="text/javascript" src="https://sagecell.sagemath.org/embedded_sagecell.js"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['\\(','\\)']],
    },
    TeX: {
        extensions: ["extpfeil.js", "autobold.js", "https://aimath.org/mathbook/mathjaxknowl.js", ],
        // scrolling to fragment identifiers is controlled by other Javascript
        positionToHash: false,
        equationNumbers: { autoNumber: "none", useLabelIds: true, },
        TagSide: "right",
        TagIndent: ".8em",
    },
    // HTML-CSS output Jax to be dropped for MathJax 3.0
    "HTML-CSS": {
        scale: 88,
        mtextFontInherit: true,
    },
    CommonHTML: {
        scale: 88,
        mtextFontInherit: true,
    },
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML-full"></script><script type="text/javascript" src="https://aimath.org/knowl.js"></script><script src="https://aimath.org/mathbook/js/lib/jquery.sticky.js"></script><script src="https://aimath.org/mathbook/js/lib/jquery.espy.min.js"></script><script src="https://aimath.org/mathbook/js/Mathbook.js"></script><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,400italic,600,600italic" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css">
<link href="https://aimath.org/mathbook/stylesheets/mathbook-3.css" rel="stylesheet" type="text/css">
<link href="https://aimath.org/mathbook/mathbook-add-on.css" rel="stylesheet" type="text/css">
</head>
<body class="mathbook-book has-toc has-sidebar-left">
<a class="assistive" href="#content">Skip to main content</a><div class="hidden-content">\(\newcommand{\set}[1]{\{1,2,\dotsc,#1\,\}}
    \newcommand{\ints}{\mathbb{Z}}
    \newcommand{\posints}{\mathbb{N}}
    \newcommand{\rats}{\mathbb{Q}}
    \newcommand{\reals}{\mathbb{R}}
    \newcommand{\complexes}{\mathbb{C}}
    \newcommand{\twospace}{\mathbb{R}^2}
    \newcommand{\threepace}{\mathbb{R}^3}
    \newcommand{\dspace}{\mathbb{R}^d}
    \newcommand{\nni}{\mathbb{N}_0}
    \newcommand{\nonnegints}{\mathbb{N}_0}
    \newcommand{\dom}{\operatorname{dom}}
    \newcommand{\ran}{\operatorname{ran}}
    \newcommand{\prob}{\operatorname{prob}}
    \newcommand{\Prob}{\operatorname{Prob}}
    \newcommand{\height}{\operatorname{height}}
    \newcommand{\width}{\operatorname{width}}
    \newcommand{\length}{\operatorname{length}}
    \newcommand{\crit}{\operatorname{crit}}
    \newcommand{\inc}{\operatorname{inc}}
    \newcommand{\HP}{\mathbf{H_P}}
    \newcommand{\HCP}{\mathbf{H^c_P}}
    \newcommand{\GP}{\mathbf{G_P}}
    \newcommand{\GQ}{\mathbf{G_Q}}
    \newcommand{\AG}{\mathbf{A_G}}
    \newcommand{\GCP}{\mathbf{G^c_P}}
    \newcommand{\PXP}{\mathbf{P}=(X,P)}
    \newcommand{\QYQ}{\mathbf{Q}=(Y,Q)}
    \newcommand{\GVE}{\mathbf{G}=(V,E)}
    \newcommand{\HWF}{\mathbf{H}=(W,F)}
    \newcommand{\bfC}{\mathbf{C}}
    \newcommand{\bfG}{\mathbf{G}}
    \newcommand{\bfH}{\mathbf{H}}
    \newcommand{\bfF}{\mathbf{F}}
    \newcommand{\bfI}{\mathbf{I}}
    \newcommand{\bfK}{\mathbf{K}}
    \newcommand{\bfP}{\mathbf{P}}
    \newcommand{\bfQ}{\mathbf{Q}}
    \newcommand{\bfR}{\mathbf{R}}
    \newcommand{\bfS}{\mathbf{S}}
    \newcommand{\bfT}{\mathbf{T}}
    \newcommand{\bfNP}{\mathbf{NP}}
    \newcommand{\bftwo}{\mathbf{2}}
    \newcommand{\cgA}{\mathcal{A}}
    \newcommand{\cgB}{\mathcal{B}}
    \newcommand{\cgC}{\mathcal{C}}
    \newcommand{\cgD}{\mathcal{D}}
    \newcommand{\cgE}{\mathcal{E}}
    \newcommand{\cgF}{\mathcal{F}}
    \newcommand{\cgG}{\mathcal{G}}
    \newcommand{\cgM}{\mathcal{M}}
    \newcommand{\cgN}{\mathcal{N}}
    \newcommand{\cgP}{\mathcal{P}}
    \newcommand{\cgR}{\mathcal{R}}
    \newcommand{\cgS}{\mathcal{S}}
    \newcommand{\bfn}{\mathbf{n}}
    \newcommand{\bfm}{\mathbf{m}}
    \newcommand{\bfk}{\mathbf{k}}
    \newcommand{\bfs}{\mathbf{s}}
    \newcommand{\bijection}{\xrightarrow[\text{onto}]{\text{$1$--$1$}}}
    \newcommand{\injection}{\xrightarrow[]{\text{$1$--$1$}}}
    \newcommand{\surjection}{\xrightarrow[\text{onto}]{}}
    \newcommand{\nin}{\not\in}
    \newcommand{\prufer}{\mbox{prüfer}}
    \DeclareMathOperator{\fix}{fix}
    \DeclareMathOperator{\stab}{stab}
    \DeclareMathOperator{\var}{var}
    \newcommand{\inv}{^{-1}}
\newcommand{\lt}{&lt;}
\newcommand{\gt}{&gt;}
\newcommand{\amp}{&amp;}
\)</div>
<header id="masthead" class="smallbuttons"><div class="banner"><div class="container">
<a id="logo-link" href=""></a><div class="title-container">
<h1 class="heading"><a href="MAS341.html"><span class="title">MAS341: Graph Theory</span></a></h1>
<p class="byline"></p>
</div>
</div></div>
<nav id="primary-navbar" class="navbar"><div class="container">
<div class="navbar-top-buttons">
<button class="sidebar-left-toggle-button button active">Contents</button><div class="tree-nav toolbar toolbar-divisor-3"><span class="threebuttons"><a id="previousbutton" class="previous-button toolbar-item button" href="ch_algorithms.html" title="Previous" alt="Previous">Prev</a><a id="upbutton" class="up-button button toolbar-item" href="ch_algorithms.html" title="Up" alt="Up">Up</a><a id="nextbutton" class="next-button button toolbar-item" href="s_graphalgorithms_digraphs.html" title="Next" alt="Next">Next</a></span></div>
<button class="sidebar-right-toggle-button button active">Annotations</button>
</div>
<div class="navbar-bottom-buttons toolbar toolbar-divisor-4">
<button class="sidebar-left-toggle-button button toolbar-item active">Contents</button><a class="previous-button toolbar-item button" href="ch_algorithms.html" title="Previous" alt="Previous">Prev</a><a class="up-button button toolbar-item" href="ch_algorithms.html" title="Up" alt="Up">Up</a><a class="next-button button toolbar-item" href="s_graphalgorithms_digraphs.html" title="Next" alt="Next">Next</a>
</div>
</div></nav></header><div class="page">
<aside id="sidebar-left" class="sidebar"><div class="sidebar-content">
<nav id="toc"><h2 class="link"><a href="frontmatter-1.html" data-scroll="frontmatter-1"><span class="title">Front Matter</span></a></h2>
<h2 class="link"><a href="ch_intro.html" data-scroll="ch_intro"><span class="codenumber">1</span><span class="title">Introduction</span></a></h2>
<ul>
<li><a href="s_intro_firstlook.html" data-scroll="s_intro_firstlook">A first look a graphs</a></li>
<li><a href="s_intro_degrees.html" data-scroll="s_intro_degrees">Degree and handshaking</a></li>
<li><a href="s_intro_isomorphisms.html" data-scroll="s_intro_isomorphisms">Graph Isomorphisms</a></li>
<li><a href="s_intro_instantinsanity.html" data-scroll="s_intro_instantinsanity">Instant Insanity</a></li>
<li><a href="s_intro_exercises.html" data-scroll="s_intro_exercises">Exercises</a></li>
</ul>
<h2 class="link"><a href="ch_walks.html" data-scroll="ch_walks"><span class="codenumber">2</span><span class="title">Walks</span></a></h2>
<ul>
<li><a href="s_walks_basics.html" data-scroll="s_walks_basics">Walks: the basics</a></li>
<li><a href="s_walks_hamiltonian.html" data-scroll="s_walks_hamiltonian">Hamiltonian cycles</a></li>
<li><a href="s_walks_exercises.html" data-scroll="s_walks_exercises">Exercises</a></li>
</ul>
<h2 class="link active"><a href="ch_algorithms.html" data-scroll="ch_algorithms"><span class="codenumber">3</span><span class="title">Algorithms</span></a></h2>
<ul>
<li><a href="s_graphalgorithms_min-wt-span.html" data-scroll="s_graphalgorithms_min-wt-span" class="active">Minimum Weight Spanning Trees</a></li>
<li><a href="s_graphalgorithms_digraphs.html" data-scroll="s_graphalgorithms_digraphs">Digraphs</a></li>
<li><a href="s_graphalgorithms_shortest-paths.html" data-scroll="s_graphalgorithms_shortest-paths">Dijkstra's Algorithm for Shortest Paths</a></li>
<li><a href="s_graphalgorithms_exercises.html" data-scroll="s_graphalgorithms_exercises">Exercises</a></li>
</ul></nav><div class="extras"><nav><a class="mathbook-link" href="https://mathbook.pugetsound.edu">Authored in PreTeXt</a><a href="https://www.mathjax.org"><img title="Powered by MathJax" src="https://www.mathjax.org/badge/badge.gif" border="0" alt="Powered by MathJax"></a></nav></div>
</div></aside><main class="main"><div id="content" class="mathbook-content"><section class="section" id="s_graphalgorithms_min-wt-span"><h2 class="heading hide-type" alt="Section 3.1 Minimum Weight Spanning Trees">
<span class="type">Section</span><span class="codenumber">3.1</span><span class="title">Minimum Weight Spanning Trees</span>
</h2>
<a href="s_graphalgorithms_min-wt-span.html" class="permalink">¶</a><section class="introduction" id="introduction-6"><p id="p-131">In this section, we consider pairs \((\bfG,w)\) where \(\GVE\) is a connected graph and \(w\colon E\rightarrow\nonnegints\text{.}\) For each edge \(e\in E\text{,}\) the quantity \(w(e)\) is called the <dfn class="terminology">weight</dfn> of \(e\text{.}\) Given a set \(S\) of edges, we define the <dfn class="terminology">weight</dfn> of \(S\text{,}\) denoted \(w(S)\text{,}\) by setting \(w(S)=\sum_{e\in S} w(e)\text{.}\) In particular, the weight of a spanning tree \(T\) is just the sum of the weights of the edges in \(T\text{.}\)</p>
<p id="p-132">Weighted graphs arise in many contexts. One of the most natural is when the weights on the edges are distances or costs. For example, consider the weighted graph in <a knowl="./knowl/fig_graphalgorithms_spantreegraph.html" knowl-id="xref-fig_graphalgorithms_spantreegraph" alt="Figure 3.1.1 " title="Figure 3.1.1 ">Figure 3.1.1</a>. Suppose the vertices represent nodes of a network and the edges represent the ability to establish direct physical connections between those nodes. The weights associated to the edges represent the cost (let's say in thousands of dollars) of building those connections. The company establishing the network among the nodes only cares that there is a way to get data between each pair of nodes. Any additional links would create redundancy in which they are not interested at this time. A spanning tree of the graph ensures that each node can communicate with each of the others and has no redundancy, since removing any edge disconnects it. Thus, to minimize the cost of building the network, we want to find a minimum weight (or cost) spanning tree.</p>
<figure class="figure-like" id="fig_graphalgorithms_spantreegraph"><img src="images/spantreegraph.svg" width="90%" style="display: block; margin: 0 auto;" alt=""><figcaption><span class="type">Figure</span><span class="codenumber">3.1.1</span>A weighted graph</figcaption></figure><p id="p-133">To do this, this section considers the following problem:</p>
<article class="example-like"><a knowl="" class="id-ref" refid="hk-problem-1" id="problem-1"><h6 class="heading">
<span class="type">Problem</span><span class="codenumber">3.1.2</span>
</h6></a></article><div id="hk-problem-1" class="hidden-content tex2jax_ignore"><article class="example-like"><p id="p-134">Find a minimum weight spanning tree \(\bfT\) of \(\bfG\text{.}\)</p></article></div>
<p id="p-135">To solve this problem, we will develop <em class="emphasis">two</em> efficient graph algorithms, each having certain computational advantages and disadvantages. Before developing the algorithms, we need to establish some preliminaries about spanning trees and forests.</p></section><section class="subsection" id="subsection-16"><h3 class="heading hide-type" alt="Subsection 3.1.1 Preliminaries">
<span class="type">Subsection</span><span class="codenumber">3.1.1</span><span class="title">Preliminaries</span>
</h3>
<p id="p-136">The following proposition about the number of components in a spanning forest of a graph \(\bfG\) has an easy inductive proof. You are asked to provide it in the exercises.</p>
<article class="theorem-like" id="prop_graphalgorithms_spanforest"><h6 class="heading">
<span class="type">Proposition</span><span class="codenumber">3.1.3</span>
</h6>
<p id="p-137">Let \(\GVE\) be a graph on \(n\) vertices, and let \(\bfH=(V,S)\) be a spanning forest. Then \(0\le |S|\le n-1\text{.}\) Furthermore, if \(|S|= n-k\text{,}\) then \(\bfH\) has \(k\) components. In particular, \(\bfH\) is a spanning tree if and only if it contains \(n-1\) edges.</p></article><p id="p-138">The following proposition establishes a way to take a spanning tree of a graph, remove an edge from it, and add an edge of the graph that is not in the spanning tree to create a new spanning tree. Effectively, the process exchanges two edges to form the new spanning tree, so we call this the <dfn class="terminology">exchange principle</dfn>.</p>
<article class="theorem-like" id="prop_graphalgorithms_exchange"><h6 class="heading">
<span class="type">Proposition</span><span class="codenumber">3.1.4</span><span class="title">Exchange Principle</span>
</h6>
<p id="p-139">Let \(\bfT=(V,S)\) be spanning tree in a graph \(\bfG\text{,}\) and let \(e=xy\) be an edge of \(\bfG\) which does not belong to \(\bfT\text{.}\) Then </p>
<ol class="decimal">
<li id="li-41"><p id="p-140">There is a <em class="emphasis">unique</em> path \(P=(x_0,x_1,x_2,\dots,x_t)\) with (a) \(x=x_0\text{;}\) (b) \(y=x_t\text{;}\) and (c) \(x_ix_{i+1}\in S\) for each \(i=0,1,2,\dots,t-1\text{.}\)</p></li>
<li id="li-42">
<p id="p-141">For each \(i=0,1,2,\dots,t-1\text{,}\) let \(f_i=x_ix_{i+1}\) and then set</p>
<div class="displaymath">
\begin{equation*}
S_i = \{e\}\cup\{g\in S: g\neq f_i\},
\end{equation*}
</div>
<p>i.e., we <dfn class="terminology">exchange</dfn> edge \(f_i\) for edge \(e\text{.}\) Then \(\bfT_i=(V,S_i)\) is a spanning tree of \(\bfG\text{.}\)</p>
</li>
</ol></article><article class="hiddenproof"><a knowl="" class="id-ref" refid="hk-proof-4" id="proof-4"><h6 class="heading"><span class="type">Proof</span></h6></a></article><div id="hk-proof-4" class="hidden-content tex2jax_ignore"><article class="hiddenproof"><p id="p-142">For the first fact, it suffices to note that if there were more than one distinct path from \(x\) to \(y\) in \(\bfT\text{,}\) we would be able to find a cycle in \(\bfT\text{.}\) This is impossible since it is a tree. For the second, we refer to <a knowl="./knowl/fig_graphalgorithms_exchange.html" knowl-id="xref-fig_graphalgorithms_exchange" alt="Figure 3.1.5 " title="Figure 3.1.5 ">Figure 3.1.5</a>. The black and green edges in the graph shown at the left represent the spanning tree \(\bfT\text{.}\) Thus, \(f\) lies on the unique path from \(x\) to \(y\) in \(\bfT\) and \(e=xy\) is an edge of \(\bfG\) <em class="emphasis">not</em> in \(\bfT\text{.}\) Adding \(e\) to \(\bfT\) creates a graph with a unique cycle, since \(\bfT\) had a unique path from \(x\) to \(y\text{.}\) Removing \(f\) (which could be any edge \(f_i\) of the path, as stated in the proposition) destroys this cycle. Thus \(\bfT_i\) is a connected acyclic subgraph of \(\bfG\) with \(n-1+1-1=n-1\) edges, so it is a spanning tree.</p>
<figure class="figure-like" id="fig_graphalgorithms_exchange"><div class="sidebyside" id="sidebyside-4"><div class="sbsrow" style="margin-left:1%;margin-right:1%;">
<div class="sbspanel" style="width:48.9795918367347%;justify-content:flex-start;"><img src="images/exchange1.svg" width="100%" style="display: block; margin: 0 auto;" alt=""></div>
<div class="sbspanel" style="width:48.9795918367347%;justify-content:flex-start;"><img src="images/exchange2.svg" width="100%" style="display: block; margin: 0 auto;" alt=""></div>
</div></div>
<figcaption><span class="type">Figure</span><span class="codenumber">3.1.5</span>The exchange principle</figcaption></figure></article></div>
<p id="p-143">For both of the algorithms we develop, the argument to show that the algorithm is optimal rests on the following technical lemma. To avoid trivialities, we assume \(n\ge3\text{.}\)</p>
<article class="theorem-like" id="lem_graphalgorithms_tech"><h6 class="heading">
<span class="type">Lemma</span><span class="codenumber">3.1.6</span>
</h6>
<p id="p-144">Let \(\bfF\) be a spanning forest of \(\bfG\) and let \(C\) be a component of \(\bfF\text{.}\) Also, let \(e=xy\) be an edge of minimum weight among all edges with one endpoint in \(C\) and the other not in \(C\text{.}\) Then among all spanning trees of \(\bfG\) that contain the forest \(\bfF\text{,}\) there is one of minimum weight that contains the edge \(e\text{.}\)</p></article><article class="hiddenproof"><a knowl="" class="id-ref" refid="hk-proof-5" id="proof-5"><h6 class="heading"><span class="type">Proof</span></h6></a></article><div id="hk-proof-5" class="hidden-content tex2jax_ignore"><article class="hiddenproof"><p id="p-145">Let \(\bfT=(V,S)\) be any spanning tree of minimum weight among all spanning trees that contain the forest \(\bfF\text{,}\) and suppose that \(e=xy\) is not an edge in \(\bfT\text{.}\) (If it were an edge in \(\bfT\text{,}\) we would be done.) Then let \(P=(x_0,x_1,x_2,\dots,x_t)\) be the unique path in \(\bfT\) with (a) \(x=x_0\text{;}\) (b) \(y=x_t\text{;}\) and (c) \(x_ix_{i+1}\in S\) for each \(i=0,1,2,\dots,t-1\text{.}\) Without loss of generality, we may assume that \(x=x_0\) is a vertex in \(C\) while \(y=x_t\) does not belong to \(C\text{.}\) Then there is a least non-negative integer \(i\) for which \(x_i\) is in \(C\) and \(x_{i+1}\) is not in \(C\text{.}\) It follows that \(x_j\) is in \(C\) for all \(j\) with \(0\le j\le i\text{.}\)</p>
<p id="p-146">Let \(f=x_ix_{i+1}\text{.}\) The edge \(e\) has minimum weight among all edges with one endpoint in \(C\) and the other not in \(C\text{,}\) so \(w(e)\le w(f)\text{.}\) Now let \(\bfT_i\) be the tree obtained by exchanging the edge \(f\) for edge \(e\text{.}\) It follows that \(w(\bfT_i) = w(\bfT) - w(f) +w(e)\le w(\bfT)\text{.}\) Furthermore, \(\bfT_i\) contains the spanning forest \(\bfF\) as well as the edge \(e\text{.}\) It is therefore the minimum weight spanning tree we seek.</p></article></div>
<article class="remark-like" id="remark-1"><h6 class="heading">
<span class="type">Remark</span><span class="codenumber">3.1.7</span>
</h6>
<p id="p-147">Although Bob's combinatorial intuition has improved over the course he doesn't quite understand why we need special algorithms to find minimum weight spanning trees. He figures there can't be that many spanning trees, so he wants to just write them down. Alice groans as she senses that Bob must have been absent when the material from <span>&lt;&lt;Unresolved xref, reference "s_graphs_counting-trees"; check spelling or use "provisional" attribute&gt;&gt;</span><a href="" class="xref" alt="" title=""> </a> was discussed. In that section, we learned that a graph on \(n\) vertices can have as many as \(n^{n-2}\) spanning trees (or horrors, the instructor may have left it off the syllabus). Regardless, this exhaustive approach is already unusable when \(n = 20\text{.}\) Dave mumbles something about being greedy and just adding the lightest edges one-by-one while never adding an edge that would make a cycle. Zori remembers a strategy like this working for finding the height of a poset, but she's worried about the nightmare situation that we learned about with using FirstFit to color graphs. Alice agrees that greedy algorithms have an inconsistent track record but suggests that <a knowl="./knowl/lem_graphalgorithms_tech.html" knowl-id="xref-lem_graphalgorithms_tech" alt="Lemma 3.1.6 " title="Lemma 3.1.6 ">Lemma 3.1.6</a> may be enough to get one to succeed here.</p></article></section><section class="subsection" id="subsection-17"><h3 class="heading hide-type" alt="Subsection 3.1.2 Kruskal's Algorithm">
<span class="type">Subsection</span><span class="codenumber">3.1.2</span><span class="title">Kruskal's Algorithm</span>
</h3>
<p id="p-148">In this section, we develop one of the best known algorithms for finding a minimum weight spanning tree. It is known as <dfn class="terminology">Kruskal's Algorithm</dfn>, although some prefer the descriptive label <em class="emphasis">Avoid Cycles</em> because of the way it builds the spanning tree.</p>
<p id="p-149">To start Kruskal's algorithm, we sort the edges according to weight.  To be more precise, let \(m\) denote the number of edges in \(\GVE\text{.}\)  Then label the edges as \(e_1,e_2,e_3,\dots,e_m\) so that \(w(e_1)\le w(e_2)\le \dots \le w(e_m)\text{.}\) Any of the many available efficient sorting algorithms can be used to do this step.</p>
<p id="p-150">Once the edges are sorted, Kruskal's algorithm proceeds to an initialization step and then inductively builds the spanning tree \(\bfT=(V,S)\text{:}\)</p>
<article class="theorem-like" id="alg_kruskal"><h6 class="heading">
<span class="type">Algorithm</span><span class="codenumber">3.1.8</span><span class="title">Kruskal's Algorithm</span>
</h6>
<dl id="p-151" class="description-list">
<dt id="li-43">Initialization.</dt>
<dd><p id="p-152">Set \(S=\emptyset\) and \(i=0\text{.}\)</p></dd>
<dt id="li-44">Inductive Step.</dt>
<dd>
<p id="p-153">While \(|S| \lt n-1\text{,}\) let \(j\) be the least non-negative integer so that \(j &gt; i\) and there are no cycles in \(S\cup\{e_j\}\text{.}\) Then (using pseudo-code) set</p>
<div class="displaymath">
\begin{equation*}
i = j\quad\text{and} \quad S= S\cup\{j\}.
\end{equation*}
</div>
</dd>
</dl></article><p id="p-154">The correctness of Kruskal's Algorithm follows from an inductive argument. First, the set \(S\) is initialized as the empty set, so there is certainly a minimum weight spanning tree containing all the edges in \(S\text{.}\) Now suppose that for some \(i\) with \(0\le i \lt n\text{,}\) \(|S|=i\) and there is a minimum weight spanning tree containing all the edges in \(S\text{.}\) Let \(\bfF\) be the spanning forest determined by the edges in \(S\text{,}\) and let \(C_1, C_2,\dots,C_s\) be the components of \(\bfF\text{.}\) For each \(k=1,2,\dots,s\text{,}\) let \(f_k\) be a minimum weight edge with one endpoint in \(C_k\) and the other not in \(C_k\text{.}\) Then the edge \(e\) added to \(S\) by Kruskal's Algorithm is just the edge \(\{f_1,f_2,\dots,f_s\}\) having minimum weight. Applying <a knowl="./knowl/lem_graphalgorithms_tech.html" knowl-id="xref-lem_graphalgorithms_tech" alt="Lemma 3.1.6 " title="Lemma 3.1.6 ">Lemma 3.1.6</a> and the inductive hypothesis, we know that there will still be a minimum weight spanning tree of \(\bfG\) containing all the edges of \(S\cup\{e\}\text{.}\)</p>
<article class="example-like"><a knowl="" class="id-ref" refid="hk-example-9" id="example-9"><h6 class="heading">
<span class="type">Example</span><span class="codenumber">3.1.9</span><span class="title">Kruskal's Algorithm</span>
</h6></a></article><div id="hk-example-9" class="hidden-content tex2jax_ignore"><article class="example-like"><div class="sidebyside" id="sidebyside-5"><div class="sbsrow" style="margin-left:1.25%;margin-right:1.25%;">
<div class="sbspanel" style="width:80%;justify-content:flex-start;"><p id="p-155">Let's see what Kruskal's algorithm does on the weighted graph in <a knowl="./knowl/fig_graphalgorithms_spantreegraph.html" knowl-id="xref-fig_graphalgorithms_spantreegraph" alt="Figure 3.1.1 " title="Figure 3.1.1 ">Figure 3.1.1</a>.  It first sorts all of the edges by weight. We won't reproduce the list here, since we won't need all of it. The edge of least weight is \(ck\text{,}\) which has weight \(23\text{.}\) It continues adding the edge of least weight, adding \(ag\text{,}\) \(fg\text{,}\) \(fi\text{,}\) \(fj\text{,}\) and \(bj\text{.}\) However, after doing this, the edge of lowest weight is \(fb\text{,}\) which has weight \(38\text{.}\) This edge cannot be added, as doing so would make \(fjb\) a cycle. Thus, the algorithm bypasses it and adds \(bc\text{.}\) Edge \(ai\) is next inspected, but it, too, would create a cycle and is eliminated from consideration. Then \(em\) is added, followed by \(dl\text{.}\) There are now <em class="emphasis">two</em> edges of weight \(56\) to be considered: \(al\) and \(dj\text{.}\) Our sorting algorithm has somehow decided one of them should appear first, so let's say it's \(dj\text{.}\) After adding \(dj\text{,}\) we cannot add \(al\text{,}\) as \(agfjdl\) would form a cycle. Edge \(dk\) is next considered, but it would also form a cycle. However, \(ek\) can be added. Edges \(km\) and \(dm\) are then bypassed. Finally, edge \(ch\) is added as the twelfth and final edge for this \(13\)-vertex spanning tree. The full list of edges added (in order) is shown to the right. The total weight of this spanning tree is \(504\text{.}\)</p></div>
<div class="sbspanel" style="width:17.4358974358974%;justify-content:flex-start;"><pre class="code-block tex2jax_ignore">c k 23
a g 25
f g 26
f i 29
f j 30
b j 34
b c 39
e m 49
d l 55
d j 56
e k 59
c h 79
</pre></div>
</div></div></article></div></section><section class="subsection" id="alg_prim"><h3 class="heading hide-type" alt="Subsection 3.1.3 Prim's Algorithm">
<span class="type">Subsection</span><span class="codenumber">3.1.3</span><span class="title">Prim's Algorithm</span>
</h3>
<a href="s_graphalgorithms_min-wt-span.html#alg_prim" class="permalink">¶</a><p id="p-156">We now develop <dfn class="terminology">Prim's Algorithm</dfn> for finding a minimum weight spanning tree. This algorithm is also known by a more descriptive label: <em class="emphasis">Build Tree</em>. We begin by choosing a root vertex \(r\text{.}\) Again, the algorithm proceeds with an initialization step followed by a series of inductive steps.</p>
<article class="theorem-like" id="algorithm-2"><h6 class="heading">
<span class="type">Algorithm</span><span class="codenumber">3.1.10</span><span class="title">Prim's Algorithm</span>
</h6>
<dl id="p-157" class="description-list">
<dt id="li-45">Initialization.</dt>
<dd><p id="p-158">Set \(W=\{r\}\) and \(S=\emptyset\text{.}\)</p></dd>
<dt id="li-46">Inductive Step.</dt>
<dd>
<p id="p-159">While \(|W| \lt n\text{,}\) let \(e\) be an edge of minimum weight among all edges with one endpoint in \(W\) and the other not in \(W\text{.}\)  If \(e=xy\text{,}\) \(x\in W\) and \(y\not\in W\text{,}\) update \(W\) and \(S\) by setting (using pseudo-code)</p>
<div class="displaymath">
\begin{equation*}
W = W\cup\{y\}\quad\text{and} \quad S = S\cup\{e\}.
\end{equation*}
</div>
</dd>
</dl></article><p id="p-160">The correctness of Prim's algorithm follows immediately from <a knowl="./knowl/lem_graphalgorithms_tech.html" knowl-id="xref-lem_graphalgorithms_tech" alt="Lemma 3.1.6 " title="Lemma 3.1.6 ">Lemma 3.1.6</a>.</p>
<article class="example-like"><a knowl="" class="id-ref" refid="hk-example-10" id="example-10"><h6 class="heading">
<span class="type">Example</span><span class="codenumber">3.1.11</span><span class="title">Prim's Algorithm</span>
</h6></a></article><div id="hk-example-10" class="hidden-content tex2jax_ignore"><article class="example-like"><div class="sidebyside" id="sidebyside-6"><div class="sbsrow" style="margin-left:1.25%;margin-right:1.25%;">
<div class="sbspanel" style="width:80%;justify-content:flex-start;"><p id="p-161">Let's see what Prim's algorithm does on the weighted graph in <a knowl="./knowl/fig_graphalgorithms_spantreegraph.html" knowl-id="xref-fig_graphalgorithms_spantreegraph" alt="Figure 3.1.1 " title="Figure 3.1.1 ">Figure 3.1.1</a>. We start with vertex \(a\) as the root vertex. The lightest edge connecting \(a\) (the only vertex in the tree so far) to the rest of the graph is \(ag\text{.}\) Next, \(fg\) is added. This is followed by \(fi\text{,}\) \(fj\text{,}\) \(bj\text{,}\) and \(bc\text{.}\) Next, the algorithm identifies \(ck\) as the lightest edge connecting \(\{a,g,i,f,j,b,c\}\) to the remaining vertices. Notice that this is considerably later than Kruskal's algorithm finds the same edge. The algorithm then determines that \(al\) and \(jd\text{,}\) both of weight \(56\) are the lightest edges connecting vertices in the tree to the other vertices. It picks arbitrarily, so let's say it takes \(al\text{.}\) It next finds \(dl\text{,}\) then \(ek\text{,}\) and then \(em\text{.}\) The final edge added is \(ch\text{.}\) The full list of edges added (in order) is shown to the right. The total weight of this spanning tree is \(504\text{.}\) This (not surprisingly) the same weight we obtained using Kruskal's algorithm. However, notice that the spanning tree found is different, as this one contains \(al\) instead of \(dj\text{.}\) This is not an issue, of course, since in both cases an arbitrary choice between two edges of equal weight was made.</p></div>
<div class="sbspanel" style="width:17.4358974358974%;justify-content:flex-start;"><pre class="code-block tex2jax_ignore">a g 25
f g 26
f i 29
f j 30
b j 34
b c 39
c k 23
a l 56
d l 55
e k 59
e m 49
c h 79
</pre></div>
</div></div></article></div></section><section class="subsection" id="subsection-19"><h3 class="heading hide-type" alt="Subsection 3.1.4 Comments on Efficiency">
<span class="type">Subsection</span><span class="codenumber">3.1.4</span><span class="title">Comments on Efficiency</span>
</h3>
<p id="p-162">An implementation of Kruskal's algorithm seems to require that the edges be sorted. If the graph has \(n\) vertices and \(m\) edges, this requires \(m\log m\) operations just for the sort. But once the sort is done, the process takes only \(n-1\) steps—provided you keep track of the components as the spanning forest expands.  Regardless, it is easy to see that at most \(O(n^2\log n)\) operations are required.</p>
<p id="p-163">On the other hand, an implementation of Prim's algorithm requires the program to conveniently keep track of the edges incident with each vertex and always be able to identify the edge with least weight among subsets of these edges. In computer science, the data structure that enables this task to be carried out is called a <dfn class="terminology">heap</dfn>.</p></section></section></div></main>
</div>
</body>
</html>
