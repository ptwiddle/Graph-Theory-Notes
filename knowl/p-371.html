<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*       on 2021-03-19T11:08:39Z       *-->
<!--*   A recent stable commit (2020-08-09):   *-->
<!--* 98f21740783f166a773df4dc83cab5293ab63a4a *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body>
<h6 xmlns:svg="http://www.w3.org/2000/svg" class="heading"><span class="type">Paragraph</span></h6>
<p xmlns:svg="http://www.w3.org/2000/svg">Another, slightly better, greedy algorithm might be called <em class="emphasis">nearest insertion</em>.  It inductively builds bigger and bigger closed loops one vertex at time.  When there is a closed loop with <em class="emphasis">k</em> vertices \(v_1-v_2-v_3-\cdots - v_k-v_1\) and we want to add vertex \(w\) to the loop, we look at each of the adjacent legs \(v_i-v_{i+1}\text{,}\) and determine how much it would raise the cost to insert the next vertex \(w\) in between those two cities (changing the path to \(v_1-w-v_{i+1}\)), being sure to also check for inserting it between \(v_k\) and \(v_1\text{.}\)  This does much better at our example above, but can run into other problems, and involves a little more bookkeeping and arithmetic, so I won't ask you to implement it on the exam.</p>
<span class="incontext"><a href="s_graphalgorithms_traveling-salesperson.html#p-371">in-context</a></span>
</body>
</html>
